---
import { getCollection } from "astro:content";
import TimelineEntry from "@components/Timeline/TimelineEntry.svelte";
import { sortByDate } from "@content/utils";
import EntryDeselector from "@components/Timeline/EntryDeselector.svelte";
import Markers from "@components/Timeline/Markers/Markers.svelte";
import EntryDetailsPortal from "@components/Timeline/EntryDetails/EntryDetailsPortal.astro";

const educationEntries = await getCollection("education");
const jobsEntries = await getCollection("jobs");
const projectsEntries = await getCollection("projects");

const allEntries = [...educationEntries, ...jobsEntries, ...projectsEntries];

allEntries.sort((a, b) => {
  return sortByDate(a.data.start, b.data.start);
});

const earliestStart = allEntries[0].data.start;
const latestStart = allEntries[allEntries.length - 1].data.start;

const latestEnd = allEntries.reduce((latest, entry) => {
  const end = entry.data.end;

  if (!end) {
    return latest;
  }

  if (end.year > latest.year) {
    return end;
  } else if (end.year === latest.year && end.month > latest.month) {
    return end;
  } else {
    return latest;
  }
}, latestStart);

const totalYears = latestEnd.year - earliestStart.year;
const totalMonths = totalYears * 12 + latestEnd.month - earliestStart.month + 1;

const lines: Array<[number, number, (typeof allEntries)[number]][]> = [];

allEntries.forEach((entry) => {
  const start = entry.data.start;
  const end = entry.data.end ?? latestEnd;
  const startRow =
    (start.year - earliestStart.year) * 12 +
    start.month -
    earliestStart.month +
    1; // 1 based
  let endRow =
    (end.year - earliestStart.year) * 12 + end.month - earliestStart.month + 1; // 1 based

  if (!entry.data.end) {
    // Lasts until now, so add 2 rows for '...' and 'Now' markers
    endRow += 2;
  }

  let line = lines.findIndex((line) => {
    return line.every(([start, end]) => {
      return start >= endRow || end <= startRow;
    });
  }); // 0 based

  if (line === -1) {
    line = lines.length;
    lines.push([[startRow, endRow, entry]]);
  } else {
    lines[line].push([startRow, endRow, entry]);
  }
});

const numLines = lines.length;
const numRows = totalMonths + 2; // +2 for '...' and 'Now' rows
---

<EntryDeselector client:idle />
<section class="container grid gap-4 lg:grid-cols-[auto_1fr]">
  <div class="main-timeline-grid col-start-1 row-start-1 my-16 justify-center">
    <Markers {totalMonths} {earliestStart} {latestEnd} client:visible />
    {
      lines.map((line, numLine) =>
        line.map(([startRow, endRow, entry]) => {
          return (
            <div
              class="relative"
              style={{
                gridColumn: numLine + 2,
                gridRow: `${-startRow} / ${-endRow}`,
              }}
            >
              <TimelineEntry {entry} client:visible />
            </div>
          );
        })
      )
    }
  </div>
  <EntryDetailsPortal entries={allEntries} />
</section>

<style define:vars={{ numLines, numRows }} lang="scss">
  .main-timeline-grid {
    display: grid;
    column-gap: 1rem;
    row-gap: 2px;
    grid-template-columns: auto repeat(var(--numLines), 2rem);
    grid-template-rows: repeat(var(--numRows), 60px);
  }
</style>
